###############
# Introduction
###############
- nosql database - meaning data can be inserted with no schema or relations (joins)
- concept of server (mongod) and client (mongo)
- can have many databases -> each database can have many collections (tables) -> each collections can have many documents (records/rows)
- documents can have any fields in a collection


#####################
# Installing MongoDB
#####################

## Windows
- for Community server: use msi and then click Download
https://www.mongodb.com/try/download/community

- install MongoD as a Service
search Services from windows search -> then make the MongoDB Server to run automatically when Windows starts

- Service name = MongoDB
- alternatively, to stop from command prompt
launch cmd as admin -> run command = "net stop MongoDB"
start command = "net start MongoDB"

- data and log directory:
C:\Program Files\MongoDB\Server\4.4\data
C:\Program Files\MongoDB\Server\4.4\log

- mongo client is present in (double clicking it will launch the client)
C:\Program Files\MongoDB\Server\4.4\bin\mongo.exe

- if bin is added to the PATH, then can run commands from cmd directly to start / stop server and client


## Install MongoDB shell
- alternative to legacy mongo client (installed by default), we can also install new shell
https://www.mongodb.com/try/download/shell

- install at
C:\Users\rishi\AppData\Local\Programs\mongosh\

- copy the 2 files to mongo bin directory as its already in PATH
mongosh.exe
mongocryptd-mongosh.exe


## basic commands

# run mongo database from cmd
mongod

# however, on windows, it will be started as service at system boot automatically

# run mongo client from another cmd
mongo

# mongo client commands:

# clear screen
> cls

> show dbs
admin       0.000GB
config      0.000GB
flightmgmt  0.000GB
local       0.000GB

# to create a new database and use it at same time, just run command: "use <database-name>"
> use shop
switched to db shop

# similarly to create a new collection (say, "products") and use it (insert records):
> db.products.insertOne({name: "Guitar", price: 100.99})

# use quit() to close mongo cmd prompt
> quit()


## Install mongoimport
- used to import some prepared data into a MongoDB database
https://docs.mongodb.com/database-tools/installation/installation/
https://docs.mongodb.com/database-tools/installation/installation-windows/

- other tools are also added and add bin to PATH
C:\Program Files\MongoDB\Tools\100\bin\


## use drivers
- use Java client to interact with mongod server
https://docs.mongodb.com/drivers/java-drivers/


## whole diagram                                                  Queries
frontend UI -> Backend (server) -> Drivers (Java/Python/Node.js)  =======  MongoDB Server <-> Storage Engine <-> DB (slow) or memory (fast)
                                      or
                                   MongoDB Shell


#####################

# youtube demo
# database -> collections -> documents

# database
> use mylib
switched to db mylib

# books - collection
# json - document
> db.books.insert({"name":"mongodb book"})
WriteResult({ "nInserted" : 1 })

> show dbs
admin       0.000GB
config      0.000GB
flightmgmt  0.000GB
local       0.000GB
mylib       0.000GB

> show collections
books

> db.books.find()
{ "_id" : ObjectId("60c3d287ccc13c5b49d21253"), "name" : "mongodb book" }

#####################

## Course

> use shop
switched to db shop

> db.products.insertOne({name: "A Book", price:12.99})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("60c53786d24694398ba828d7")
}

> db.products.find()
{ "_id" : ObjectId("60c53786d24694398ba828d7"), "name" : "A Book", "price" : 12.99 }

> db.products.find().pretty()
{
        "_id" : ObjectId("60c53786d24694398ba828d7"),
        "name" : "A Book",
        "price" : 12.99
}

> db.products.insertOne({name: "Guitar", price:158.2, description:"an electric guitar"})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("60c5386dd24694398ba828d8")
}

> db.products.find().pretty()
{
        "_id" : ObjectId("60c53786d24694398ba828d7"),
        "name" : "A Book",
        "price" : 12.99
}
{
        "_id" : ObjectId("60c5386dd24694398ba828d8"),
        "name" : "Guitar",
        "price" : 158.2,
        "description" : "an electric guitar"
}


> db.products.insertOne({name: "T-Shirt", price:29.0, description:"this is a high quality T-Shirt"})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("60c538f4d24694398ba828d9")
}

> db.products.find().pretty()
{
        "_id" : ObjectId("60c53786d24694398ba828d7"),
        "name" : "A Book",
        "price" : 12.99
}
{
        "_id" : ObjectId("60c5386dd24694398ba828d8"),
        "name" : "Guitar",
        "price" : 158.2,
        "description" : "an electric guitar"
}
{
        "_id" : ObjectId("60c538f4d24694398ba828d9"),
        "name" : "T-Shirt",
        "price" : 29,
        "description" : "this is a high quality T-Shirt"
}


> db.products.insertOne({name: "Computer", price:1231.99, description:"this is a high quality computer", details: {cpu: "Intel i7 8770", memory: 32}})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("60c53987d24694398ba828da")
}

> db.products.find().pretty()
{
        "_id" : ObjectId("60c53786d24694398ba828d7"),
        "name" : "A Book",
        "price" : 12.99
}
{
        "_id" : ObjectId("60c5386dd24694398ba828d8"),
        "name" : "Guitar",
        "price" : 158.2,
        "description" : "an electric guitar"
}
{
        "_id" : ObjectId("60c538f4d24694398ba828d9"),
        "name" : "T-Shirt",
        "price" : 29,
        "description" : "this is a high quality T-Shirt"
}
{
        "_id" : ObjectId("60c53987d24694398ba828da"),
        "name" : "Computer",
        "price" : 1231.99,
        "description" : "this is a high quality computer",
        "details" : {
                "cpu" : "Intel i7 8770",
                "memory" : 32
        }
}

================================

###################
# Basics
###################

- start mongod on different port than default 27017
mongod --port 27018
mongo --port 27018

- json always contain keys in double quotes,
- however, in mongodb insert commands, we can use keys without quotes
- behind the scenes, mongodb uses binary BSON to store

> use flights
switched to db flights

> db.flightData.insertOne({
...     "departureAirport": "MUC",
...     "arrivalAirport": "SFO",
...     "aircraft": "Airbus A380",
...     "distance": 12000,
...     "intercontinental": true
...   })
{
        "acknowledged" : true,
        "insertedId" : ObjectId("60ca7eb403d6d26b62b1c16c")
}

> db.flightData.find().pretty()
{
        "_id" : ObjectId("60ca7eb403d6d26b62b1c16c"),
        "departureAirport" : "MUC",
        "arrivalAirport" : "SFO",
        "aircraft" : "Airbus A380",
        "distance" : 12000,
        "intercontinental" : true
}

- _id is unique for each document
- if try to insert 2 documents with same _id, error will be thrown


###################
# CRUD operations
###################

# Create
insertOne(data, options)
insertMany(data, options)

# Read
find(filter, options)
findOne(filter, options)

# Update
updateOne(filter, data, options)
updateMany(filter, data, options)
replaceOne(filter, data, options)

# Delete
deleteOne(filter, options)
deleteMany(filter, options)


=========

> db.flightData.insertOne({"departureAirport": "TXL", "arrivalAirport": "LHR"})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("60cbd46002605fb7c8cf41f7")
}

> db.flightData.insertOne({"departureAirport": "TXL", "arrivalAirport": "LHR", _id:"txl-lhr-1"})
{ "acknowledged" : true, "insertedId" : "txl-lhr-1" }

> db.flightData.find().pretty()
{
        "_id" : ObjectId("60ca7eb403d6d26b62b1c16c"),
        "departureAirport" : "MUC",
        "arrivalAirport" : "SFO",
        "aircraft" : "Airbus A380",
        "distance" : 12000,
        "intercontinental" : true
}
{
        "_id" : ObjectId("60cbd46002605fb7c8cf41f7"),
        "departureAirport" : "TXL",
        "arrivalAirport" : "LHR"
}
{
        "_id" : "txl-lhr-1",
        "departureAirport" : "TXL",
        "arrivalAirport" : "LHR"
}

==============

## delete or update the documents

> db.flightData.deleteOne({"departureAirport" : "TXL"})
{ "acknowledged" : true, "deletedCount" : 1 }

> db.flightData.updateOne({"distance" : 12000}, {$set: {marker: "delete"}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

> db.flightData.updateMany({}, {$set: {marker: "toDelete"}})
{ "acknowledged" : true, "matchedCount" : 2, "modifiedCount" : 2 }

> db.flightData.deleteMany({marker: "toDelete"})
{ "acknowledged" : true, "deletedCount" : 2 }

============

# insertMany()

- multiple documents MUST be inserted as an array - [ {}, {}..... ]

> db.flightData.insertMany([
...   {
...     "departureAirport": "MUC",
...     "arrivalAirport": "SFO",
...     "aircraft": "Airbus A380",
...     "distance": 12000,
...     "intercontinental": true
...   },
...   {
...     "departureAirport": "LHR",
...     "arrivalAirport": "TXL",
...     "aircraft": "Airbus A320",
...     "distance": 950,
...     "intercontinental": false
...   }
... ])
{
        "acknowledged" : true,
        "insertedIds" : [
                ObjectId("60ce7a27be69cbf3e681005f"),
                ObjectId("60ce7a27be69cbf3e6810060")
        ]
}

===============

# find()

- find can be used without any filter as argument or with it

> db.flightData.find()
> db.flightData.find().pretty()
> db.flightData.find().pretty()
> db.flightData.find({intercontinental: true}).pretty()
{
        "_id" : ObjectId("60ce7a27be69cbf3e681005f"),
        "departureAirport" : "MUC",
        "arrivalAirport" : "SFO",
        "aircraft" : "Airbus A380",
        "distance" : 12000,
        "intercontinental" : true
}

- number greater than condition
> db.flightData.find({distance: {$gt: 1000}}).pretty()
{
        "_id" : ObjectId("60ce7a27be69cbf3e681005f"),
        "departureAirport" : "MUC",
        "arrivalAirport" : "SFO",
        "aircraft" : "Airbus A380",
        "distance" : 12000,
        "intercontinental" : true
}

- pretty() is not supported for findOne() because output is already pretty
> db.flightData.findOne({distance: {$gt: 900}})
{
        "_id" : ObjectId("60ce7a27be69cbf3e681005f"),
        "departureAirport" : "MUC",
        "arrivalAirport" : "SFO",
        "aircraft" : "Airbus A380",
        "distance" : 12000,
        "intercontinental" : true
}

==============

# update() and updateMany()

update() works similar to updateOne() and updateMany()
- however, if $set is not used, then one and many will give error
- but update will replace the whole document with only the updated document provided

example:

> db.flightData.find().pretty()
{
        "_id" : ObjectId("60ce7a27be69cbf3e681005f"),
        "departureAirport" : "MUC",
        "arrivalAirport" : "SFO",
        "aircraft" : "Airbus A380",
        "distance" : 12000,
        "intercontinental" : true,
        "delayed" : false
}
{
        "_id" : ObjectId("60ce7a27be69cbf3e6810060"),
        "departureAirport" : "LHR",
        "arrivalAirport" : "TXL",
        "aircraft" : "Airbus A320",
        "distance" : 950,
        "intercontinental" : false
}

> db.flightData.updateOne({_id:  ObjectId("60ce7a27be69cbf3e681005f")}, {delayed: false})
uncaught exception: Error: the update operation document must contain atomic operators :
DBCollection.prototype.updateOne@src/mongo/shell/crud_api.js:565:19
@(shell):1:1

> db.flightData.updateMany({_id:  ObjectId("60ce7a27be69cbf3e681005f")}, {delayed: false})
uncaught exception: Error: the update operation document must contain atomic operators :
DBCollection.prototype.updateMany@src/mongo/shell/crud_api.js:655:19
@(shell):1:1

> db.flightData.update({_id:  ObjectId("60ce7a27be69cbf3e681005f")}, {delayed: false})
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })

> db.flightData.find().pretty()
{ "_id" : ObjectId("60ce7a27be69cbf3e681005f"), "delayed" : false }
{
        "_id" : ObjectId("60ce7a27be69cbf3e6810060"),
        "departureAirport" : "LHR",
        "arrivalAirport" : "TXL",
        "aircraft" : "Airbus A320",
        "distance" : 950,
        "intercontinental" : false
}

- better not to use update() and use replaceOne() for replacing the whole document
- for partial changes, use updateOne or updateMany

> db.flightData.replaceOne({_id:  ObjectId("60ce7a27be69cbf3e681005f")}, {
...     "departureAirport": "MUC",
...     "arrivalAirport": "SFO",
...     "aircraft": "Airbus A380",
...     "distance": 12000,
...     "intercontinental": true
...   })
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

> db.flightData.find().pretty()
{
        "_id" : ObjectId("60ce7a27be69cbf3e681005f"),
        "departureAirport" : "MUC",
        "arrivalAirport" : "SFO",
        "aircraft" : "Airbus A380",
        "distance" : 12000,
        "intercontinental" : true
}
{
        "_id" : ObjectId("60ce7a27be69cbf3e6810060"),
        "departureAirport" : "LHR",
        "arrivalAirport" : "TXL",
        "aircraft" : "Airbus A320",
        "distance" : 950,
        "intercontinental" : false
}


#############################
# find() and the cursor object
#############################

- find() doesn't return all the data in the collection because data can be huge
- instead it returns a cursor object, can use "it" to fetch more data in cycles

- to get all the data at once, use toArray()
> db.passengers.find().toArray()

- can use forEach() for each document operation, its better for performance
> db.passengers.find().forEach((passengerData) => {printjson(passengerData)})

- pretty() is only available on cursor object got from find(), thus fails for findOne() which does not returns cursor
> db.passengers.findOne().pretty()
uncaught exception: TypeError: db.passengers.findOne(...).pretty is not a function :
@(shell):1:1


#############
# projection
#############

- when we only want a subset of document to be returned from find()
- example:
> db.passengers.find({},{name:1}).pretty()

- _id is always included
- to exlude _id explicitly
> db.passengers.find({},{name:1, _id:0}).pretty()

- filtering is done at mongod server side, so network bandwidth is saved

#############
# embedded documents
# arrays
#############

- value can have many nested documents
- upto 100 level of nesting - hard limit
- max 16MB per document

ex:
> db.flightData.updateMany({}, {$set: {status: {description: "on-time", lastUpdated: "1 hour ago", details: {responsible: "Rishi Srivastava"}}}})
{ "acknowledged" : true, "matchedCount" : 2, "modifiedCount" : 2 }

> db.flightData.find().pretty()
{
        "_id" : ObjectId("60ce7a27be69cbf3e681005f"),
        "departureAirport" : "MUC",
        "arrivalAirport" : "SFO",
        "aircraft" : "Airbus A380",
        "distance" : 12000,
        "intercontinental" : true,
        "status" : {
                "description" : "on-time",
                "lastUpdated" : "1 hour ago",
                "details" : {
                        "responsible" : "Rishi Srivastava"
                }
        }
}
{
        "_id" : ObjectId("60ce7a27be69cbf3e6810060"),
        "departureAirport" : "LHR",
        "arrivalAirport" : "TXL",
        "aircraft" : "Airbus A320",
        "distance" : 950,
        "intercontinental" : false,
        "status" : {
                "description" : "on-time",
                "lastUpdated" : "1 hour ago",
                "details" : {
                        "responsible" : "Rishi Srivastava"
                }
        }
}

---------------
# arrays
- array of embedded documents - between [ ]
- arrays can hold ANY data

ex:
> db.passengers.updateOne({name: "Albert Twostone"}, {$set: {hobbies: ["sports", "cooking"]}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

> db.passengers.find({name: "Albert Twostone"}).pretty()
{
        "_id" : ObjectId("60d501ed8a734511d0f8661b"),
        "name" : "Albert Twostone",
        "age" : 68,
        "hobbies" : [
                "sports",
                "cooking"
        ]
}

- accessing structured data using . operator
> db.passengers.findOne({name: "Albert Twostone"}).hobbies
[ "sports", "cooking" ]

- or, by using search pattern:
> db.passengers.find({hobbies: "sports"}).pretty()
{
        "_id" : ObjectId("60d501ed8a734511d0f8661b"),
        "name" : "Albert Twostone",
        "age" : 68,
        "hobbies" : [
                "sports",
                "cooking"
        ]
}

- to find all the documents for a particular key in a nested document, use . operator
ex:
{
        "_id" : ObjectId("60ce7a27be69cbf3e6810060"),
        "departureAirport" : "LHR",
        "arrivalAirport" : "TXL",
        "aircraft" : "Airbus A320",
        "distance" : 950,
        "intercontinental" : false,
        "status" : {
                "description" : "on-time",
                "lastUpdated" : "1 hour ago",
                "details" : {
                        "responsible" : "Rishi Srivastava"
                }
        }
}

- if want to find "description" : "on-time", then use . operator; remember to use key inside ""
> db.flightData.find({"status.description": "on-time"}).pretty()


- Drop a database
use <databaseName>
db.dropDatabase()

- Drop a collection
db.<collectionName>.drop()

- delete all data from a collection
db.<collectionName>.deleteMany({})


#############
# Assignment
#############

{
  firstName
  lastName
  age
  history
    [
           { disease,  treatment }
           {  }
        ]
}

- insert 3 patient records
- update patient data of 1 with new age, name and history
- find all patients older than 30
- delete all patients who got a cold

# solution
1) insert 3 patient records
use patients
db.patient.insertOne({firstName: "John", lastName: "Wright", age: 43, history: [{disease: "cold", treatment: "medicines"}, {disease: "headache", treatment: "coconut"}]})
db.patient.insertOne({firstName: "Kenneth", lastName: "Chin", age: 25, history: [{disease: "insomnia", treatment: "sleep"}]})
db.patient.insertOne({firstName: "Suphathorn", lastName: "Ramabutr", age: 41, history: [{disease: "workaholic", treatment: "holidays"}, {disease: "cold", treatment: "panadol"}]})

# could use insertMany()

db.patient.find().pretty()

2) update patient data of 1 with new age, name and history
db.patient.updateOne({firstName: "Kenneth"}, {$set: {firstName: "Garfield", lastName: "Lau", age: 29, history: [{disease: "diabetes", treatment: "insulin"}]}})

3) find all patients older than 30
db.patient.find({age: {$gt: 30}}).pretty()

4) delete all patients who got a cold
db.patient.deleteMany({"history.disease": "cold"})


#############################
# Schemas & Relations
# How to Structure Documents
#############################
- Schema means defining the table structure and type / name of columns it can hold
- MongoDB enforces no schemas => documents dont have to use the same schema inside of one collection
- better design is to have some fields which are always present in all the documents + some extra keys for few documents


#############
# Data Types
#############
- Text - always inside "" - max 16 MB
- Boolean - true / false
- Number - Integer (int32), NumberLong (int64), NumberDecimal
by default its decimal number as JavaScript has default Number
- ObjectId - unique _id
- ISODate - "yyyy-mm-dd"
- Timestamp
- Embedded Document - {"a": { ... }}
- Array - {"b": [ ... ]}

example:
db.companies.insertOne({name: "Fresh Apples Inc", isStartup: true, employees: 33, funding: 12345678901234567890, details: {ceo: "Mark Super"},
tags: [{title: "super"}, {title: "perfect"}], foundingDate: new Date(), insertedAt: new Timestamp()})

- get information about database
> db.stats()
{
        "db" : "companyData",
        "collections" : 2,
        "views" : 0,
        "objects" : 2,
        "avgObjSize" : 134.5,
        "dataSize" : 269,
        "storageSize" : 24576,
        "indexes" : 2,
        "indexSize" : 24576,
        "totalSize" : 49152,
        "scaleFactor" : 1,
        "fsUsedSize" : 489910005760,
        "fsTotalSize" : 499337080832,
        "ok" : 1
}

- can store as 32-bit number instead of default 64-bit float
> db.numbers.insertOne({b: NumberInt(1)})

- to check the type of a key use "typeof"
> typeof db.numbers.findOne().a
number
> typeof db.numbers.findOne().b
undefined

- if need double precision - just like BigDecimal("123.456") in Java, use NumberDecimal("12.99")
companyData> db.numbers.insertOne({c: NumberDecimal("12.99")})

companyData> typeof db.numbers.findOne().c
undefined


## Data Schemas & Data Modelling
1) Which Data does my App need or generate ?
User, Product, Orders, etc.

- Defines the fields we will need (and how they relate)

2) Where do I need my data ?
UI, products list page, orders page, etc.

- Defines the required collections + field groupings

3) Which kind of data or information do I want to display?
UI, products list page, orders page, etc.

- Defines which queries we will need

4) How often do I fetch my data?
ex: For every page reload

- Defines whether you should optimize for easy fetching

5) How often do I write or change my data?
Orders => often; Product Data => rarely

- Defines whether you should optimize for easy writing


## Understanding Relations
- want to put all the embedded documents in 1 collection or split into mulitple collections
ex: user collection and has different embedded documents like favorite books, hobbies, etc
option 1 is to put all in user collection
option 2 is to have separate collections for books, hobbies etc and use unique id to join them


##################################
# One to one relation - embedded
##################################

## Example 1 - Patient <-> Disease summary

# first using option 2 (join / use reference key)

- mongo shell:
------------------------------------
companyData> use hospital
switched to db hospital

hospital> db.patients.insertOne({name: "Max", age: 29, diseaseSummary: "summary-max-1"})
{
  acknowledged: true,
  insertedId: ObjectId("623fa424bd001f554cfea95e")
}

hospital> db.patients.find()
[
  {
    _id: ObjectId("623fa424bd001f554cfea95e"),
    name: 'Max',
    age: 29,
    diseaseSummary: 'summary-max-1'
  }
]

hospital> db.diseaseSummaries.insertOne({_id: "summary-max-1", diseases: ["cold", "broken leg"]})
{ acknowledged: true, insertedId: 'summary-max-1' }

hospital> db.diseaseSummaries.find()
[ { _id: 'summary-max-1', diseases: [ 'cold', 'broken leg' ] } ]

hospital> var dsid = db.patients.findOne().diseaseSummary

hospital> dsid
summary-max-1

hospital> db.diseaseSummaries.findOne({_id: dsid})
{ _id: 'summary-max-1', diseases: [ 'cold', 'broken leg' ] }
------------------------------------

- however, performance wise it's not good

# so better use option 1 - put it as embedded document

- mongo shell:
------------------------------------
hospital> db.patients.deleteMany({})
{ acknowledged: true, deletedCount: 1 }

hospital> db.patients.insertOne({name: "Max", age: 29, diseaseSummary: {diseases: ["cold", "broken leg"]}})
{
  acknowledged: true,
  insertedId: ObjectId("623fa6d4bd001f554cfea95f")
}

hospital> db.patients.find()
[
  {
    _id: ObjectId("623fa6d4bd001f554cfea95f"),
    name: 'Max',
    age: 29,
    diseaseSummary: { diseases: [ 'cold', 'broken leg' ] }
  }
]
------------------------------------


## Example 2 - Person <-> Car

- sometimes option 2 (use reference key) is useful based on use case
- mongo shell:
------------------------------------
hospital> use carData
switched to db carData

carData> db.persons.insertOne({name: "Max", car: {model: "BMW", price: 40000}})
{
  acknowledged: true,
  insertedId: ObjectId("623fa9d0bd001f554cfea960")
}

carData> db.persons.find()
[
  {
    _id: ObjectId("623fa9d0bd001f554cfea960"),
    name: 'Max',
    car: { model: 'BMW', price: 40000 }
  }
]

# better use option 2

carData> db.persons.deleteMany({})
{ acknowledged: true, deletedCount: 1 }

carData> db.persons.insertOne({name: "Max", age:29, salary:3000})
{
  acknowledged: true,
  insertedId: ObjectId("623faad7bd001f554cfea961")
}

carData> db.cars.insertOne({model: "BMW", price: 40000, owner: ObjectId("623faad7bd001f554cfea961")})
{
  acknowledged: true,
  insertedId: ObjectId("623fab1ebd001f554cfea962")
}

------------------------------------


##################################
# One to many relation - embedded
##################################

## Example 3 - Thread <-> Answers
- one thread has many answers, one answer belongs to one question thread

- mongo shell
------------------------------------
test> use support
switched to db support

support> db.questionThreads.insertOne({creator: "Max", question: "How does that all work?", answers: ["q1a1", "q1a2"]})
{
  acknowledged: true,
  insertedId: ObjectId("6240f9d2b23bd2d6489848ed")
}

support> db.questionThreads.find()
[
  {
    _id: ObjectId("6240f9d2b23bd2d6489848ed"),
    creator: 'Max',
    question: 'How does that all work?',
    answers: [ 'q1a1', 'q1a2' ]
  }
]

support> db.answers.insertMany([{_id: "q1a1", text: "It works like that."}, {_id: "q1a2", text: "Thanks!"}])
{ acknowledged: true, insertedIds: { '0': 'q1a1', '1': 'q1a2' } }

support> db.answers.find()
[
  { _id: 'q1a1', text: 'It works like that.' },
  { _id: 'q1a2', text: 'Thanks!' }
]


# however better design will be to use embedded document rather than reference/join

support> db.questionThreads.deleteMany({})
{ acknowledged: true, deletedCount: 1 }

support> db.questionThreads.insertOne({creator: "Max", question: "How does that work?", answers: [{text: "Like that."}, {text: "Thanks!"}]})
{
  acknowledged: true,
  insertedId: ObjectId("6240fbc4b23bd2d6489848ee")
}

support> db.questionThreads.find()
[
  {
    _id: ObjectId("6240fbc4b23bd2d6489848ee"),
    creator: 'Max',
    question: 'How does that work?',
    answers: [ { text: 'Like that.' }, { text: 'Thanks!' } ]
  }
]

------------------------------------


## Example 4 - City <-> Citizens
- one city has many citizens, one citizen belongs to one city
- use references instead of embedded documents because there can be millions of citizens and thus can hit the limit of 16MB per document

- mongo shell:
------------------------------------
support> use cityData
switched to db cityData

cityData> db.cities.insertOne({name: "New York City", coordinates: {lat: 21, lng: 55}})
{
  acknowledged: true,
  insertedId: ObjectId("6240fee7b23bd2d6489848ef")
}

cityData> db.citizens.insertMany([{name: "Max Schwarzmueller", cityId: ObjectId("6240fee7b23bd2d6489848ef")}, {name: "Manuel Lorenz", cityId: ObjectId("6240fee7b23bd2d6489848ef")}])
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId("62410540b23bd2d6489848f0"),
    '1': ObjectId("62410540b23bd2d6489848f1")
  }
}

cityData> db.citizens.find()
[
  {
    _id: ObjectId("62410540b23bd2d6489848f0"),
    name: 'Max Schwarzmueller',
    cityId: ObjectId("6240fee7b23bd2d6489848ef")
  },
  {
    _id: ObjectId("62410540b23bd2d6489848f1"),
    name: 'Manuel Lorenz',
    cityId: ObjectId("6240fee7b23bd2d6489848ef")
  }
]

------------------------------------



##################################
# Many to Many relation - embedded
##################################

## Example 5 - Customers <-> Products (Orders)
- Many customers can have many products

- mongo shell:
------------------------------------
shop> db.products.find().pretty()
[
  {
    _id: ObjectId("60c53786d24694398ba828d7"),
    name: 'A Book',
    price: 12.99
  },
  {
    _id: ObjectId("60c5386dd24694398ba828d8"),
    name: 'Guitar',
    price: 158.2,
    description: 'an electric guitar'
  }
]

shop> db.customers.insertOne({name: "Max", age: 29})
{
  acknowledged: true,
  insertedId: ObjectId("6248dffacb06b38b4f96d1df")
}

shop> db.orders.insertOne({productId: ObjectId("60c53786d24694398ba828d7"), customcustomerId: ObjectId("6248dffacb06b38b4f96d1df")})
{
  acknowledged: true,
  insertedId: ObjectId("6248e064cb06b38b4f96d1e0")
}

# or, we can delete orders collection and use embedded
- customers will have embedded orders

shop> db.customers.updateOne({}, {$set: {orders: [{productId: ObjectId("60c53786d24694398ba828d7"), quantity: 2}]}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}

shop> db.customers.find()
[
  {
    _id: ObjectId("6248dffacb06b38b4f96d1df"),
    name: 'Max',
    age: 29,
    orders: [
      { productId: ObjectId("60c53786d24694398ba828d7"), quantity: 2 }
    ]
  }
]



############################################
# Many to Many relation - using references
############################################

## Example 6 - Books <-> Authors
- One book has many authors, an author belongs to many books

- mongo shell:
------------------------------------
test> use bookRegistry

bookRegistry> db.books.insertOne({name: "My fav book", authors: [{name: "Max", age: 29}, {name: "John", age: 30}]})
{
  acknowledged: true,
  insertedId: ObjectId("6248e725cb06b38b4f96d1e1")
}

bookRegistry> db.books.find().pretty()
[
  {
    _id: ObjectId("6248e725cb06b38b4f96d1e1"),
    name: 'My fav book',
    authors: [ { name: 'Max', age: 29 }, { name: 'John', age: 30 } ]
  }
]

bookRegistry> db.authors.insertMany([{name: "Max", age: 29, address: {street: "Main"}}, {name: "John", age: 30, address: {street: "Tree"}}])
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId("6248e86bcb06b38b4f96d1e2"),
    '1': ObjectId("6248e86bcb06b38b4f96d1e3")
  }
}

# better to use references as author age will change or other details like address

bookRegistry> db.books.updateOne({}, {$set: {authors: [ObjectId("6248e86bcb06b38b4f96d1e2"), ObjectId("6248e86bcb06b38b4f96d1e3")]}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}

bookRegistry> db.books.find()
[
  {
    _id: ObjectId("6248e725cb06b38b4f96d1e1"),
    name: 'My fav book',
    authors: [
      ObjectId("6248e86bcb06b38b4f96d1e2"),
      ObjectId("6248e86bcb06b38b4f96d1e3")
    ]
  }
]


######################
# Summary - relations
######################

# use embedded:
- group data together logically
- great for data that belong together without any duplicates
- avoid super deep nesting (100+ levels) or document size limit of 16 MB
- dont use for example in case if a User is there -> if the User details change, then need to change all the documents

# use references:
- split data across collections
- great for related but shared data with duplicates
- no issue of deep nesting or size limits


##############################
# Use lookup() for references
##############################
- we can use lookup method to get documents from other referenced collections

- mongo shell:
------------------------------------
bookRegistry> db.books.find()
[
  {
    _id: ObjectId("6248e725cb06b38b4f96d1e1"),
    name: 'My fav book',
    authors: [
      ObjectId("6248e86bcb06b38b4f96d1e2"),
      ObjectId("6248e86bcb06b38b4f96d1e3")
    ]
  }
]

bookRegistry> db.authors.find()
[
  {
    _id: ObjectId("6248e86bcb06b38b4f96d1e2"),
    name: 'Max',
    age: 29,
    address: { street: 'Main' }
  },
  {
    _id: ObjectId("6248e86bcb06b38b4f96d1e3"),
    name: 'John',
    age: 30,
    address: { street: 'Tree' }
  }
]

bookRegistry> db.books.aggregate([{$lookup: {from: "authors", localField: "authors", foreignField: "_id", as: "creators"}}]).pretty()
[
  {
    _id: ObjectId("6248e725cb06b38b4f96d1e1"),
    name: 'My fav book',
    authors: [
      ObjectId("6248e86bcb06b38b4f96d1e2"),
      ObjectId("6248e86bcb06b38b4f96d1e3")
    ],
    creators: [
      {
        _id: ObjectId("6248e86bcb06b38b4f96d1e2"),
        name: 'Max',
        age: 29,
        address: { street: 'Main' }
      },
      {
        _id: ObjectId("6248e86bcb06b38b4f96d1e3"),
        name: 'John',
        age: 30,
        address: { street: 'Tree' }
      }
    ]
  }
]


##########################
# Exercise project - Blog
##########################
- database: blog
- collections: User, Post
- Post has got embedded Comments and reference for User

- mongo shell:
------------------------------------
bookRegistry> use blog
switched to db blog

blog> db.users.insertMany([{name: "Max Schwarz", age: 29, email: "max@test.com"}, {name: "Manuel Lorenz", age: 30, email: "manu@test.com"}])
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId("624a3258a0270b69c8e755ae"),
    '1': ObjectId("624a3258a0270b69c8e755af")
  }
}

blog> db.users.find()
[
  {
    _id: ObjectId("624a3258a0270b69c8e755ae"),
    name: 'Max Schwarz',
    age: 29,
    email: 'max@test.com'
  },
  {
    _id: ObjectId("624a3258a0270b69c8e755af"),
    name: 'Manuel Lorenz',
    age: 30,
    email: 'manu@test.com'
  }
]


blog> db.posts.insertOne({title: "My first Post!", text: "This is my first post, I hope you like it!", tags: ["new", "tech"], creator: ObjectId("624a3258a0270b69c8e755af"), comments: [{text: "I like this post!", author: ObjectId("624a3258a0270b69c8e755ae")}]})
{
  acknowledged: true,
  insertedId: ObjectId("624a3447a0270b69c8e755b0")
}

blog> db.posts.find()
[
  {
    _id: ObjectId("624a3447a0270b69c8e755b0"),
    title: 'My first Post!',
    text: 'This is my first post, I hope you like it!',
    tags: [ 'new', 'tech' ],
    creator: ObjectId("624a3258a0270b69c8e755af"),
    comments: [
      {
        text: 'I like this post!',
        author: ObjectId("624a3258a0270b69c8e755ae")
      }
    ]
  }
]


#####################
# Schema Validation
#####################
- schema can be validated in MongoDB - means insertOne() command can fail if validation fails

# validationLevel
- Which documents get validated?
strict -> all inserts & updates
moderate - all inserts & updates to correct documents

# validationAction
- What happens if validation fails?
error -> throw error and deny insert/update
warn -> log warning but proceed


blog> db.createCollection('posts', { validator: { $jsonSchema: { bsonType: 'object', required: ['title', 'text', 'creator', 'comments'], properties: { title: { bsonType: "string", description: "must be a string and is required" }, text: { bsonType: "string", description: "must be a string and is required" }, creator: { bsonType: "objectId", description: "must be a objectId and is required" }, comments: { bsonType: "array", description: "must be an array and is required", items: { bsonType: "object", required: ["text", "author"], properties: { text: { bsonType: "string", description: "must be a string and is required" }, author: { bsonType: 'objectId', description: "must be a objectId and is required" } } } } } } } });
{ ok: 1 }

blog> db.posts.insertOne({title: "My first Post!", text: "This is my first post, I hope you like it!", tags: ["new", "tech"], creator: ObjectId("624a3258a0270b69c8e755af"), comments: [{text: "I like this post!", author: 123}]})
MongoServerError: Document failed validation


# validation can be changed from error to warn
- attached validation-2.js can be used to change the action to warning message in logs


#################
# Schema wrap up
#################
- in which format will you fetch your data ?
- how often will you fetch and change your data ?
- how much data will you save (and how big is it) ?
- how is your data related ?
- will duplicates hurt you (=> many updates) ?
- will you hit data/storage limits ?

- 2 options: embedded or references
- embedded suited more for one-to-one or one-to-many relations
- references suited more for many-to-many relations


----------------------------


#################################
# Working with Shell and Server
#################################
- start mongodb server as process & service
- configuring database & log path (and mode)
- fixing issues


- start from cmd
mongod
mongo

- get all the options
mongod --help

# set "dbpath" & "logpath"
- default data and log directory:
C:\Program Files\MongoDB\Server\4.4\data
C:\Program Files\MongoDB\Server\4.4\log

- can change wherever needed
mongod --dbpath C:\Program Files\MongoDB\db
mongod --dbpath C:\Program Files\MongoDB\db --logpath C:\Program Files\MongoDB\logs\logs.log


# mongod as a background service
- on macos / linux
mongod --fork --logpath /user/mongodb/logs/log.log

- on windows, open cmd in admin mode
net start MongoDB

- to shutdown background service
mongo
> use admin
> db.shutdownServer()

or
net stop MongoDB


# using a config file
- also have a mongod.cfg file in bin
C:\Program Files\MongoDB\Server\4.4\bin

- can use to pass config file when mongod is started
mongod -f C:\Program Files\MongoDB\Server\4.4\bin\mongod.cfg


# mongo client shell
mongo --help

> help
> help admin
> db.help()
> db.test.help()


#####################
# Create - deep dive
#####################
- insertOne()
db.collectionName.insertOne({field: "value"})

- insertMany()
db.collectionName.insertMany([{field: "value"}, {field: "value"}])

- insert()    // deprecated
db.collectionName.insert()

- mongoimport
mongoimport -d cars -c carsList --drop --jsonArray

- mongo shell:
------------------------------------
test> use contactData
switched to db contactData

contactData> db.persons.insertOne({name: "Max", age: 30, hobbies: ["Sports", "Cooking"]})
{
  acknowledged: true,
  insertedId: ObjectId("625665844b051cf5c0954d0f")
}

contactData> db.persons.insertOne({name: "Manuel", age: 31, hobbies: ["Cars", "Cooking"]})
{
  acknowledged: true,
  insertedId: ObjectId("625665a94b051cf5c0954d10")
}

contactData> db.persons.insertMany([{name: "Anna", age: 29, hobbies: ["Cycling", "Yoga"]}])
{
  acknowledged: true,
  insertedIds: { '0': ObjectId("625666344b051cf5c0954d11") }
}

contactData> db.persons.insertMany([{name: "Maria", age: 31}, {name: "Chris", age: 25}])
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId("625666a04b051cf5c0954d12"),
    '1': ObjectId("625666a04b051cf5c0954d13")
  }
}

contactData> db.persons.insert({name: "Phil", age: 35, hobbies: ["Gym", "Cooking"]})
DeprecationWarning: Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.
{
  acknowledged: true,
  insertedIds: { '0': ObjectId("625667024b051cf5c0954d14") }
}



## Ordered insert

test> use ordered
switched to db ordered

ordered> db.hobbies.insertMany([{_id: "sports", name: "Sports"}, {_id: "cooking", name: "Cooking"}, {_id: "cars", name: "Cars"}])
{
  acknowledged: true,
  insertedIds: { '0': 'sports', '1': 'cooking', '2': 'cars' }
}

ordered> db.hobbies.find()
[
  { _id: 'sports', name: 'Sports' },
  { _id: 'cooking', name: 'Cooking' },
  { _id: 'cars', name: 'Cars' }
]

- if we insert new documents with same _id, it will fail and give error

ordered> db.hobbies.insertMany([{_id: "yoga", name: "Yoga"}, {_id: "cooking", name: "Cooking"}, {_id: "hiking", name: "Hiking"}])
Uncaught:
MongoBulkWriteError: E11000 duplicate key error collection: ordered.hobbies index: _id_ dup key: { _id: "cooking" }
Result: BulkWriteResult {
  result: {
    ok: 1,
    writeErrors: [
      WriteError {
        err: {
          index: 1,
          code: 11000,
          errmsg: 'E11000 duplicate key error collection: ordered.hobbies index: _id_ dup key: { _id: "cooking" }',
          errInfo: undefined,
          op: { _id: 'cooking', name: 'Cooking' }
        }
      }
    ],
    writeConcernErrors: [],
    insertedIds: [
      { index: 0, _id: 'yoga' },
      { index: 1, _id: 'cooking' },
      { index: 2, _id: 'hiking' }
    ],
    nInserted: 1,
    nUpserted: 0,
    nMatched: 0,
    nModified: 0,
    nRemoved: 0,
    upserted: []
  }
}

- however, if want to still get all the non duplicate entries inserted, add one additional argument to insertMany()

ordered> db.hobbies.insertMany([{_id: "yoga", name: "Yoga"}, {_id: "cooking", name: "Cooking"}, {_id: "hiking", name: "Hiking"}], {ordered: false})
.. error for duplicates ..

- however, non duplicate got inserted:

ordered> db.hobbies.find()
[
  { _id: 'sports', name: 'Sports' },
  { _id: 'cooking', name: 'Cooking' },
  { _id: 'cars', name: 'Cars' },
  { _id: 'yoga', name: 'Yoga' },
  { _id: 'hiking', name: 'Hiking' }
]



## write concerns
- if we dont want to get any acknowledgement from server, we can use write concern as w:0

test> use contactData
switched to db contactData

contactData> db.persons.insertOne({name: "Chrissy", age: 41}, {writeConcern: {w: 0}})
{
  acknowledged: false,
  insertedId: ObjectId("625a024342eea5f4c9ed20bc")
}

- default is acknowledged, so no need to set it explicitly:
contactData> db.persons.insertOne({name: "Alex", age: 36}, {writeConcern: {w: 1}})
{
  acknowledged: true,
  insertedId: ObjectId("625a02bb42eea5f4c9ed20bd")
}

- journalling at Storage engine is false or undefined by default:
contactData> db.persons.insertOne({name: "Michael", age: 51}, {writeConcern: {w: 1, j: false}})
{
  acknowledged: true,
  insertedId: ObjectId("625a032742eea5f4c9ed20be")
}

- however, we can set journalling to true, this will be slower but it will write to storage endine logs
contactData> db.persons.insertOne({name: "Michaelaa", age: 51}, {writeConcern: {w: 1, j: true}})
{
  acknowledged: true,
  insertedId: ObjectId("625a039042eea5f4c9ed20bf")
}

- we can also specify timeout - if journalling cannot complete within the timeout
contactData> db.persons.insertOne({name: "Aliya", age: 22}, {writeConcern: {w: 1, j: true, wtimeout: 200}})
{
  acknowledged: true,
  insertedId: ObjectId("625a03e942eea5f4c9ed20c0")
}

contactData> db.persons.insertOne({name: "Ranbeer", age: 23}, {writeConcern: {w: 1, j: true, wtimeout: 1}})
{
  acknowledged: true,
  insertedId: ObjectId("625a042142eea5f4c9ed20c1")
}


## What is Atomicity
- for ex: say operation - insertOne()
if error - rolled back - nothing is saved
if success - saved as a whole

- MongoDB CRUD operations are Atomic on the Document level (including Embedded Documents)


---------------------

# Assignment 2
Tasks:

- insert multiple companies (company data of your choice) into a collection - both with insertOne() and insertMany()
- deliberately insert duplicate ID data and "fix" failing additions with unordered inserts
- write data for a new company with both journalling being guaranteed and not being guaranteed


Solution:

companyData> use assignment2
switched to db assignment2

assignment2> db.companies.insertOne({_id: "apple", name: "Apple", domain: "Technology"})
{ acknowledged: true, insertedId: 'apple' }

assignment2> db.companies.insertMany([{_id: "msft", name: "Microsft", domain: "Technology"}, {_id: "wmt", name: "Walmart", domain: "departmental store"}])
{ acknowledged: true, insertedIds: { '0': 'msft', '1': 'wmt' } }

assignment2> db.companies.find()
[
  { _id: 'apple', name: 'Apple', domain: 'Technology' },
  { _id: 'msft', name: 'Microsft', domain: 'Technology' },
  { _id: 'wmt', name: 'Walmart', domain: 'departmental store' }
]


assignment2> db.companies.insertMany([{_id: "msft", name: "Microsft dupl", domain: "Technology"}, {_id: "fb", name: "Facebook", domain: "technology"}, { _id: 'googl', name: 'Google', domain: 'Technology' }])
Uncaught:
MongoBulkWriteError: E11000 duplicate key error collection: assignment2.companies index: _id_ dup key: { _id: "msft" }
Result: BulkWriteResult {
  result: {
    ok: 1,
    writeErrors: [
      WriteError {
        err: {
          index: 0,
          code: 11000,
          errmsg: 'E11000 duplicate key error collection: assignment2.companies index: _id_ dup key: { _id: "msft" }',
          errInfo: undefined,
          op: { _id: 'msft', name: 'Microsft dupl', domain: 'Technology' }
        }
      }
    ],
    writeConcernErrors: [],
    insertedIds: [
      { index: 0, _id: 'msft' },
      { index: 1, _id: 'fb' },
      { index: 2, _id: 'googl' }
    ],
    nInserted: 0,
    nUpserted: 0,
    nMatched: 0,
    nModified: 0,
    nRemoved: 0,
    upserted: []
  }
}

assignment2> db.companies.find()
[
  { _id: 'apple', name: 'Apple', domain: 'Technology' },
  { _id: 'msft', name: 'Microsft', domain: 'Technology' },
  { _id: 'wmt', name: 'Walmart', domain: 'departmental store' }
]

assignment2> db.companies.insertMany([{_id: "msft", name: "Microsft dupl", domain: "Technology"}, {_id: "fb", name: "Facebook", domain: "technology"}, { _id: 'googl', name: 'Google', domain: 'Technology' }], {ordered: false})
<errors for msft>

assignment2> db.companies.find()
[
  { _id: 'apple', name: 'Apple', domain: 'Technology' },
  { _id: 'msft', name: 'Microsft', domain: 'Technology' },
  { _id: 'wmt', name: 'Walmart', domain: 'departmental store' },
  { _id: 'fb', name: 'Facebook', domain: 'technology' },
  { _id: 'googl', name: 'Google', domain: 'Technology' }
]

assignment2> db.companies.insertOne({_id: "nke", name: "Nike", domain: "Shoes"}, {writeConcern: {w: 1, j: true}})
{ acknowledged: true, insertedId: 'nke' }

assignment2> db.companies.insertOne({_id: "ads", name: "Adidas", domain: "Shoes"}, {writeConcern: {w: 1, j: false}})
{ acknowledged: true, insertedId: 'ads' }

assignment2> db.companies.find()
[
  { _id: 'apple', name: 'Apple', domain: 'Technology' },
  { _id: 'msft', name: 'Microsft', domain: 'Technology' },
  { _id: 'wmt', name: 'Walmart', domain: 'departmental store' },
  { _id: 'fb', name: 'Facebook', domain: 'technology' },
  { _id: 'googl', name: 'Google', domain: 'Technology' },
  { _id: 'nke', name: 'Nike', domain: 'Shoes' },
  { _id: 'ads', name: 'Adidas', domain: 'Shoes' }
]


## mongoimport
- utility can be used to manually huge set of data from json file
- example:
mongoimport tv-shows.json -d movieData -c movies --jsonArray --drop


##################################
# Read operations - A closer look
##################################
- methods, filters & operators
- query selectors (READ)
- projection operators (READ)


- syntax:
db.myCollection.myMethod({})

db.employees.find({age: 30})
db.employees.find({age: {$gt : 30}})

- mongo shell
test> use movieData
switched to db movieData

movieData> show collections
movies

movieData> db.movies.findOne()

- findOne() will find the first document from collection
- find() will give first 20 documents with a cursor - type "it" to fetch more

movieData> db.movies.find()

- once put a filter - we can specify which documents we want to fetch

movieData> db.movies.find({name: "The Last Ship"})


## Comparison operators
movieData> db.movies.find({runtime: {$ne: 60}})
movieData> db.movies.find({runtime: {$lt: 40}})
movieData> db.movies.find({runtime: {$lte: 40}})
movieData> db.movies.find({runtime: {$gt: 40}})
movieData> db.movies.find({runtime: {$gte: 40}})


## querying embedded field
- field should be in "" otherwise . will fail as syntax error
- example:
movieData> db.movies.find({"rating.average": {$gt: 7}})

- querying a field from array
- just need to give any 1 field from the array
- example:
movieData> db.movies.find({genres: "Drama"})

- $in operator
- same as "in" in sql
- $nin is oppposite
- example:
movieData> db.movies.find({runtime: {$in: [30, 42]}})


## Logical operators
$and, $not, $nor, $or

- example:
movieData> db.movies.find({"rating.average": {$lt: 5}}).count()
2

movieData> db.movies.find({"rating.average": {$gt: 9.3}}).count()
2

movieData> db.movies.find({$or: [{"rating.average": {$gt: 9.3}}, {"rating.average": {$lt: 5}}]})
movieData> db.movies.find({$nor: [{"rating.average": {$gt: 9.3}}, {"rating.average": {$lt: 5}}]})






